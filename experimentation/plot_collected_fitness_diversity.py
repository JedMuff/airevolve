"""
Script to load and plot fitness and diversity data from CSV files
generated by the data collection script.
Enhanced to support 2D arrays of experiment names with custom colors.
"""

import os
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
from typing import Dict, List, Optional, Union


def load_experiment_data(data_dir: str, experiment_names: Union[List[str], List[List[str]]]) -> Dict[str, pd.DataFrame]:
    """Load fitness and diversity data for multiple experiments."""
    experiment_data = {}
    
    # Flatten experiment_names if it's a 2D array
    flat_experiment_names = []
    if isinstance(experiment_names[0], list):
        for row in experiment_names:
            flat_experiment_names.extend(row)
    else:
        flat_experiment_names = experiment_names
    
    for experiment_name in flat_experiment_names:
        csv_path = os.path.join(data_dir, experiment_name, "fitness_diversity_data.csv")
        
        if os.path.exists(csv_path):
            df = pd.read_csv(csv_path)
            experiment_data[experiment_name] = df
            print(f"Loaded data for {experiment_name}: {len(df)} rows")
        else:
            print(f"Warning: Data file not found for {experiment_name} at {csv_path}")
    
    return experiment_data


def aggregate_runs_by_generation(df: pd.DataFrame) -> Dict[str, np.ndarray]:
    """Aggregate fitness and diversity data across runs for each generation."""
    # Group by generation and collect data across all runs
    grouped = df.groupby('generation')
    
    # Find the maximum number of runs across all generations
    max_runs = 0
    for gen, group in grouped:
        max_runs = max(max_runs, len(group))
    
    max_generation = df['generation'].max()
    
    # Initialize arrays with NaN values
    max_fitness_array = np.full((max_generation + 1, max_runs), np.nan)
    mean_fitness_array = np.full((max_generation + 1, max_runs), np.nan)
    std_fitness_array = np.full((max_generation + 1, max_runs), np.nan)
    diversity_array = np.full((max_generation + 1, max_runs), np.nan)
    
    # Fill in the data where it exists
    for gen, group in grouped:
        for idx, (_, row) in enumerate(group.iterrows()):
            if idx < max_runs:  # Only fill up to max_runs to avoid index errors
                max_fitness_array[gen, idx] = row['max_fitness']
                mean_fitness_array[gen, idx] = row['mean_fitness']
                std_fitness_array[gen, idx] = row['std_fitness']
                diversity_array[gen, idx] = row['diversity']
    
    return {
        'max_fitness': max_fitness_array,
        'mean_fitness': mean_fitness_array,
        'std_fitness': std_fitness_array,
        'diversity': diversity_array
    }


def calculate_fitness_improvement(experiment_data: Dict[str, pd.DataFrame]) -> Dict[str, Dict[str, float]]:
    """
    Calculate the percentage improvement in average max fitness from first to last generation.
    Returns a dictionary with improvement statistics for each experiment.
    """
    improvement_stats = {}
    
    for exp_name, df in experiment_data.items():
        # Get first generation data (generation 0)
        first_gen_data = df[df['generation'] == 0]
        # Get last generation data
        last_gen = df['generation'].max()
        last_gen_data = df[df['generation'] == last_gen]
        
        if len(first_gen_data) == 0 or len(last_gen_data) == 0:
            print(f"Warning: Missing data for first or last generation in {exp_name}")
            continue
        
        # Calculate average max fitness for first and last generations
        first_gen_avg_max_fitness = first_gen_data['max_fitness'].mean()
        last_gen_avg_max_fitness = last_gen_data['max_fitness'].mean()
        
        # Handle cases where first generation fitness might be zero or negative
        if first_gen_avg_max_fitness == 0:
            if last_gen_avg_max_fitness == 0:
                percentage_increase = 0.0
            else:
                percentage_increase = float('inf')  # Infinite improvement
        elif first_gen_avg_max_fitness < 0 and last_gen_avg_max_fitness < 0:
            # Both negative: improvement means getting closer to zero (less negative)
            percentage_increase = ((first_gen_avg_max_fitness - last_gen_avg_max_fitness) / abs(first_gen_avg_max_fitness)) * 100
        elif first_gen_avg_max_fitness < 0 and last_gen_avg_max_fitness >= 0:
            # Went from negative to positive or zero
            percentage_increase = ((last_gen_avg_max_fitness - first_gen_avg_max_fitness) / abs(first_gen_avg_max_fitness)) * 100
        else:
            # Standard case: both positive
            percentage_increase = ((last_gen_avg_max_fitness - first_gen_avg_max_fitness) / first_gen_avg_max_fitness) * 100
        
        improvement_stats[exp_name] = {
            'first_gen_avg_max_fitness': first_gen_avg_max_fitness,
            'last_gen_avg_max_fitness': last_gen_avg_max_fitness,
            'percentage_increase': percentage_increase,
            'absolute_improvement': last_gen_avg_max_fitness - first_gen_avg_max_fitness,
            'first_generation': 0,
            'last_generation': last_gen
        }
    
    return improvement_stats


def generate_latex_table(improvement_stats: Dict[str, Dict[str, float]], save_path: Optional[str] = None) -> str:
    """
    Generate a LaTeX table from fitness improvement statistics.
    
    Args:
        improvement_stats: Dictionary containing improvement statistics for each experiment
        save_path: Optional path to save the LaTeX table to a .tex file
    
    Returns:
        String containing the LaTeX table code
    """
    
    # Start building the LaTeX table
    latex_lines = []
    latex_lines.append("\\begin{table}[htbp]")
    latex_lines.append("\\centering")
    latex_lines.append("\\caption{Fitness Improvement Summary}")
    latex_lines.append("\\label{tab:fitness_improvement}")
    latex_lines.append("\\begin{tabular}{|l|c|c|c|c|}")
    latex_lines.append("\\hline")
    latex_lines.append("\\textbf{Experiment} & \\textbf{First Gen} & \\textbf{Last Gen} & \\textbf{Improvement} & \\textbf{Percentage} \\\\")
    latex_lines.append("\\hline")
    
    # Add data rows
    for exp_name, stats in improvement_stats.items():
        # Clean up experiment name for LaTeX (replace underscores)
        clean_exp_name = exp_name.replace('_', '\\_')
        
        first_gen = stats['first_gen_avg_max_fitness']
        last_gen = stats['last_gen_avg_max_fitness']
        improvement = stats['absolute_improvement']
        
        if stats['percentage_increase'] == float('inf'):
            percentage = "Infinite"
        else:
            percentage = f"{stats['percentage_increase']:.2f}\\%"
        
        latex_lines.append(f"{clean_exp_name} & {first_gen:.4f} & {last_gen:.4f} & {improvement:.4f} & {percentage} \\\\")
        latex_lines.append("\\hline")
    
    latex_lines.append("\\end{tabular}")
    latex_lines.append("\\end{table}")
    
    # Join all lines
    latex_table = "\n".join(latex_lines)
    
    # Save to file if path provided
    if save_path:
        latex_file_path = os.path.join(save_path, "fitness_improvement_table.tex")
        with open(latex_file_path, 'w') as f:
            f.write(latex_table)
        print(f"LaTeX table saved to: {latex_file_path}")
    
    return latex_table


def print_fitness_improvement_summary(improvement_stats: Dict[str, Dict[str, float]]):
    """Print a formatted summary of fitness improvements for all experiments."""
    
    print("\n" + "="*80)
    print("FITNESS IMPROVEMENT SUMMARY")
    print("="*80)
    
    for exp_name, stats in improvement_stats.items():
        print(f"\nExperiment: {exp_name}")
        print(f"{'='*len(exp_name)}=========")
        print(f"First Generation (Gen {stats['first_generation']}) Avg Max Fitness: {stats['first_gen_avg_max_fitness']:.4f}")
        print(f"Last Generation (Gen {stats['last_generation']}) Avg Max Fitness:  {stats['last_gen_avg_max_fitness']:.4f}")
        print(f"Absolute Improvement: {stats['absolute_improvement']:.4f}")
        
        if stats['percentage_increase'] == float('inf'):
            print(f"Percentage Increase: Infinite (improved from 0)")
        else:
            print(f"Percentage Increase: {stats['percentage_increase']:.2f}%")
    
    print("\n" + "="*80)
    
    # Create a summary table
    if improvement_stats:
        print("\nSUMMARY TABLE:")
        print("-" * 100)
        print(f"{'Experiment':<20} {'First Gen':<12} {'Last Gen':<12} {'Improvement':<12} {'Percentage':<12}")
        print("-" * 100)
        
        for exp_name, stats in improvement_stats.items():
            if stats['percentage_increase'] == float('inf'):
                pct_str = "Infinite"
            else:
                pct_str = f"{stats['percentage_increase']:.2f}%"
            
            print(f"{exp_name:<20} {stats['first_gen_avg_max_fitness']:<12.4f} "
                  f"{stats['last_gen_avg_max_fitness']:<12.4f} "
                  f"{stats['absolute_improvement']:<12.4f} {pct_str:<12}")
        
        print("-" * 100)


def plot_fitness_from_csv(ax, df: pd.DataFrame, gen_line: Optional[int] = None, 
                         log: bool = False, pltmax: bool = True, label: Optional[str] = None, 
                         color: Optional[str] = None, legend: bool = True,
                         xlabel_fontsize: int = 12, ylabel_fontsize: int = 12,
                         tick_fontsize: int = 10):
    """Plot fitness data from CSV DataFrame using aggregated run data."""
    
    # Aggregate data across runs for each generation
    agg_data = aggregate_runs_by_generation(df)
    
    max_fitness_data = agg_data['max_fitness']
    mean_fitness_data = agg_data['mean_fitness']
    
    # Handle infinities and nans
    max_fitness_data[max_fitness_data == -np.inf] = np.nan
    max_fitness_data[max_fitness_data == np.inf] = np.nan
    mean_fitness_data[mean_fitness_data == -np.inf] = np.nan
    mean_fitness_data[mean_fitness_data == np.inf] = np.nan
    
    if log:
        max_fitness_data = -np.log(-max_fitness_data)
        mean_fitness_data = -np.log(-mean_fitness_data)
    
    # Calculate statistics across runs for each generation
    mean_of_means = np.nanmean(mean_fitness_data, axis=1)
    std_of_means = np.nanstd(mean_fitness_data, axis=1)
    mean_of_maxs = np.nanmean(max_fitness_data, axis=1)
    std_of_maxs = np.nanstd(max_fitness_data, axis=1)
    
    generations = np.arange(len(mean_of_means))
    
    # Create labels
    label1 = f"{label} Mean Fitness" if label is not None else 'Mean Fitness'
    label2 = f"{label} Max Fitness" if label is not None else 'Max Fitness'
    
    # Plot mean fitness
    ax.plot(generations, mean_of_means, label=label1 if legend else None, color=color)
    ax.fill_between(generations, mean_of_means - std_of_means, 
                   mean_of_means + std_of_means, alpha=0.2, color=color)
    
    # Plot max fitness if requested
    if pltmax:
        ax.plot(generations, mean_of_maxs, linestyle='--', label=label2 if legend else None, color=color)
        ax.fill_between(generations, mean_of_maxs - std_of_maxs, 
                       mean_of_maxs + std_of_maxs, alpha=0.1, color=color)
    
    # Add generation line if specified
    if gen_line is not None:
        y_max = np.nanmax(mean_of_maxs)
        y_min = np.nanmin(mean_of_means)
        ax.plot([gen_line, gen_line], [y_min, y_max], color="black", linestyle=':')
    
    ax.set_xlabel('Generation', fontsize=xlabel_fontsize)
    ax.set_ylabel('Fitness', fontsize=ylabel_fontsize)
    ax.tick_params(axis='both', which='major', labelsize=tick_fontsize)
    
    if legend:
        ax.legend()
    ax.grid()
    ax.set_ylim([np.nanmin(mean_of_means) * 0.95, np.nanmax(mean_of_maxs) * 1.05])


def plot_diversity_from_csv(ax, df: pd.DataFrame, title: str = 'Diversity', 
                           label: Optional[str] = None, color: str = 'b',
                           xlabel_fontsize: int = 12, ylabel_fontsize: int = 12,
                           tick_fontsize: int = 10):
    """Plot diversity data from CSV DataFrame."""
    
    # Aggregate data across runs for each generation
    agg_data = aggregate_runs_by_generation(df)
    diversity_data = agg_data['diversity']  # Shape: (generations, runs)
    
    # Calculate mean and std across runs for each generation
    means = np.nanmean(diversity_data, axis=1)
    stds = np.nanstd(diversity_data, axis=1)
    
    # Handle cases where all values are NaN for a generation
    valid_mask = ~np.isnan(means)
    generations = np.arange(len(means))
    
    # Only plot generations that have valid data
    if np.any(valid_mask):
        ax.plot(generations[valid_mask], means[valid_mask], label=label, color=color)
        ax.fill_between(generations[valid_mask], 
                       (means - stds)[valid_mask], 
                       (means + stds)[valid_mask], 
                       alpha=0.2, color=color)
    
    ax.set_xlabel('Generation', fontsize=xlabel_fontsize)
    ax.set_ylabel('Diversity', fontsize=ylabel_fontsize)
    ax.tick_params(axis='both', which='major', labelsize=tick_fontsize)
    ax.grid(True)
    if label is not None:
        ax.legend()


def plot_single_experiment(experiment_data: Dict[str, pd.DataFrame], 
                          experiment_name: str, save_path: Optional[str] = None,
                          fitness_figsize: tuple = (10, 6), diversity_figsize: tuple = (10, 6),
                          xlabel_fontsize: int = 12, ylabel_fontsize: int = 12,
                          tick_fontsize: int = 10):
    """Create separate plots for fitness and diversity for a single experiment."""
    
    if experiment_name not in experiment_data:
        print(f"No data found for experiment: {experiment_name}")
        return
    
    df = experiment_data[experiment_name]
    
    # Create fitness plot
    fig_fitness, ax_fitness = plt.subplots(1, 1, figsize=fitness_figsize)
    plot_fitness_from_csv(ax_fitness, df, color='red', legend=False,
                         xlabel_fontsize=xlabel_fontsize, ylabel_fontsize=ylabel_fontsize,
                         tick_fontsize=tick_fontsize)
    
    plt.tight_layout()
    
    if save_path:
        fitness_path = os.path.join(save_path, f"{experiment_name}_fitness.png")
        plt.savefig(fitness_path, dpi=300, bbox_inches='tight')
        print(f"Saved fitness plot for {experiment_name}")
    
    # plt.show()
    
    # Create diversity plot
    fig_diversity, ax_diversity = plt.subplots(1, 1, figsize=diversity_figsize)
    plot_diversity_from_csv(ax_diversity, df, color='red', label=None,
                           xlabel_fontsize=xlabel_fontsize, ylabel_fontsize=ylabel_fontsize,
                           tick_fontsize=tick_fontsize)
    
    plt.tight_layout()
    
    if save_path:
        diversity_path = os.path.join(save_path, f"{experiment_name}_diversity.png")
        plt.savefig(diversity_path, dpi=300, bbox_inches='tight')
        print(f"Saved diversity plot for {experiment_name}")
    
    # plt.show()


def plot_grouped_experiments(experiment_data: Dict[str, pd.DataFrame], 
                           experiments_row: List[str], 
                           column_colors: List = ['blue'],
                           save_path: Optional[str] = None,
                           row_name: Optional[str] = None,
                           fitness_figsize: tuple = (10, 6), 
                           diversity_figsize: tuple = (10, 6),
                           xlabel_fontsize: int = 12, 
                           ylabel_fontsize: int = 12,
                           tick_fontsize: int = 10):
    """
    Create separate plots for fitness and diversity for multiple experiments on the same graph.
    Similar to plot_single_experiment but for multiple experiments overlaid.
    """
    
    # Filter experiments that have data
    available_experiments = [exp for exp in experiments_row if exp in experiment_data]
    
    if not available_experiments:
        print(f"No data found for any experiments in row: {experiments_row}")
        return
    
    # Find the maximum number of generations across all experiments in this row
    max_generations = 40
    # for exp_name in available_experiments:
    #     max_gen = experiment_data[exp_name]['generation'].max()
    #     max_generations = max(max_generations, max_gen)
    
    # Pre-calculate fitness limits across all experiments for proper scaling
    all_mean_mins, all_mean_maxs, all_max_mins, all_max_maxs = [], [], [], []
    
    for exp_name in available_experiments:
        df = experiment_data[exp_name]
        agg_data = aggregate_runs_by_generation(df)
        
        max_fitness_data = agg_data['max_fitness']
        mean_fitness_data = agg_data['mean_fitness']
        
        # Handle infinities and nans
        max_fitness_data[max_fitness_data == -np.inf] = np.nan
        max_fitness_data[max_fitness_data == np.inf] = np.nan
        mean_fitness_data[mean_fitness_data == -np.inf] = np.nan
        mean_fitness_data[mean_fitness_data == np.inf] = np.nan
        
        # Calculate statistics
        mean_of_means = np.nanmean(mean_fitness_data, axis=1)
        mean_of_maxs = np.nanmean(max_fitness_data, axis=1)
        
        all_mean_mins.append(np.nanmin(mean_of_means))
        all_mean_maxs.append(np.nanmax(mean_of_means))
        all_max_mins.append(np.nanmin(mean_of_maxs))
        all_max_maxs.append(np.nanmax(mean_of_maxs))
    
    # Calculate overall limits
    overall_min = min(min(all_mean_mins), min(all_max_mins))
    overall_max = max(max(all_mean_maxs), max(all_max_maxs))
    
    # Create fitness plot
    fig_fitness, ax_fitness = plt.subplots(1, 1, figsize=fitness_figsize)
    
    for i,exp_name in enumerate(available_experiments):
        df = experiment_data[exp_name]
        
        # Plot fitness with shared color but different labels
        # Temporarily disable automatic y-limits in the plotting function
        plot_fitness_from_csv(ax_fitness, df, label=exp_name, color=column_colors[i], 
                             legend=True,
                             xlabel_fontsize=xlabel_fontsize, 
                             ylabel_fontsize=ylabel_fontsize,
                             tick_fontsize=tick_fontsize)
    
    # Set proper limits after all plots are added
    ax_fitness.set_xlim(0, max_generations)
    ax_fitness.set_ylim([overall_min * 0.95, overall_max * 1.05])
    plt.tight_layout()
    
    # Save fitness plot
    if save_path:
        if row_name:
            fitness_filename = f"{row_name}_grouped_fitness.png"
        else:
            fitness_filename = f"{'_'.join(available_experiments)}_grouped_fitness.png"
        
        fitness_path = os.path.join(save_path, fitness_filename)
        plt.savefig(fitness_path, dpi=300, bbox_inches='tight')
        print(f"Saved grouped fitness plot: {fitness_filename}")
    
    # plt.show()
    
    # Pre-calculate diversity limits across all experiments
    all_diversity_mins, all_diversity_maxs = [], []
    
    for exp_name in available_experiments:
        df = experiment_data[exp_name]
        agg_data = aggregate_runs_by_generation(df)
        diversity_data = agg_data['diversity']
        
        means = np.nanmean(diversity_data, axis=1)
        valid_means = means[~np.isnan(means)]
        
        if len(valid_means) > 0:
            all_diversity_mins.append(np.nanmin(valid_means))
            all_diversity_maxs.append(np.nanmax(valid_means))
    
    # Create diversity plot
    fig_diversity, ax_diversity = plt.subplots(1, 1, figsize=diversity_figsize)
    
    for i,exp_name in enumerate(available_experiments):
        df = experiment_data[exp_name]
        
        # Plot diversity with shared color but different labels
        plot_diversity_from_csv(ax_diversity, df, label=exp_name, color=column_colors[i],
                              xlabel_fontsize=xlabel_fontsize, 
                              ylabel_fontsize=ylabel_fontsize,
                              tick_fontsize=tick_fontsize)
    
    # Set proper limits after all plots are added
    ax_diversity.set_xlim(0, max_generations)
    if all_diversity_mins and all_diversity_maxs:
        diversity_min = min(all_diversity_mins)
        diversity_max = max(all_diversity_maxs)
        ax_diversity.set_ylim([diversity_min * 0.95, diversity_max * 1.05])
    
    plt.tight_layout()
    
    # Save diversity plot
    if save_path:
        if row_name:
            diversity_filename = f"{row_name}_grouped_diversity.png"
        else:
            diversity_filename = f"{'_'.join(available_experiments)}_grouped_diversity.png"
        
        diversity_path = os.path.join(save_path, diversity_filename)
        plt.savefig(diversity_path, dpi=300, bbox_inches='tight')
        print(f"Saved grouped diversity plot: {diversity_filename}")
    
    # plt.show()


def plot_comparison(experiment_data: Dict[str, pd.DataFrame], 
                   experiments_to_compare: List[str], 
                   save_path: Optional[str] = None,
                   figsize: tuple = (12, 8),
                   xlabel_fontsize: int = 12, ylabel_fontsize: int = 12,
                   tick_fontsize: int = 10):
    """Create separate comparison plots for fitness, diversity, and max fitness."""
    
    colors = ['blue', 'red', 'green', 'orange', 'purple', 'brown', 'pink']
    
    # Find the maximum number of generations across all experiments
    max_generations = 0
    for exp_name in experiments_to_compare:
        if exp_name in experiment_data:
            max_gen = experiment_data[exp_name]['generation'].max()
            max_generations = max(max_generations, max_gen)
    
    # Create fitness comparison plot
    fig_fitness, ax_fitness = plt.subplots(1, 1, figsize=figsize)
    
    for i, exp_name in enumerate(experiments_to_compare):
        if exp_name in experiment_data:
            color = colors[i % len(colors)]
            df = experiment_data[exp_name]
            
            # Plot fitness comparison (mean fitness only)
            plot_fitness_from_csv(ax_fitness, df, label=exp_name, color=color, 
                                legend=True, pltmax=False,
                                xlabel_fontsize=xlabel_fontsize, 
                                ylabel_fontsize=ylabel_fontsize,
                                tick_fontsize=tick_fontsize)
    
    ax_fitness.set_xlim(0, max_generations)
    plt.tight_layout()
    
    if save_path:
        plt.savefig(os.path.join(save_path, "fitness_comparison.png"), 
                   dpi=300, bbox_inches='tight')
        print("Saved fitness comparison plot")
    
    # plt.show()
    
    # Create diversity comparison plot
    fig_diversity, ax_diversity = plt.subplots(1, 1, figsize=figsize)
    
    for i, exp_name in enumerate(experiments_to_compare):
        if exp_name in experiment_data:
            color = colors[i % len(colors)]
            df = experiment_data[exp_name]
            
            # Plot diversity comparison
            plot_diversity_from_csv(ax_diversity, df, label=exp_name, color=color,
                                  xlabel_fontsize=xlabel_fontsize, 
                                  ylabel_fontsize=ylabel_fontsize,
                                  tick_fontsize=tick_fontsize)
    
    ax_diversity.set_xlim(0, max_generations)
    plt.tight_layout()
    
    if save_path:
        plt.savefig(os.path.join(save_path, "diversity_comparison.png"), 
                   dpi=300, bbox_inches='tight')
        print("Saved diversity comparison plot")
    
    # plt.show()
    
    # Create max fitness comparison plot
    fig_max_fitness, ax_max_fitness = plt.subplots(1, 1, figsize=figsize)
    
    for i, exp_name in enumerate(experiments_to_compare):
        if exp_name in experiment_data:
            color = colors[i % len(colors)]
            df = experiment_data[exp_name]
            
            # Aggregate data and plot max fitness only
            agg_data = aggregate_runs_by_generation(df)
            max_fitness_data = agg_data['max_fitness']
            
            # Handle infinities and nans
            max_fitness_data[max_fitness_data == -np.inf] = np.nan
            max_fitness_data[max_fitness_data == np.inf] = np.nan
            
            # Calculate statistics across runs for each generation
            mean_of_maxs = np.nanmean(max_fitness_data, axis=1)
            std_of_maxs = np.nanstd(max_fitness_data, axis=1)
            
            generations = np.arange(len(mean_of_maxs))
            
            # Plot max fitness
            ax_max_fitness.plot(generations, mean_of_maxs, label=exp_name, color=color)
            ax_max_fitness.fill_between(generations, mean_of_maxs - std_of_maxs, 
                                      mean_of_maxs + std_of_maxs, alpha=0.2, color=color)
    
    ax_max_fitness.set_xlabel('Generation', fontsize=xlabel_fontsize)
    ax_max_fitness.set_ylabel('Max Fitness', fontsize=ylabel_fontsize)
    ax_max_fitness.tick_params(axis='both', which='major', labelsize=tick_fontsize)
    ax_max_fitness.legend()
    ax_max_fitness.grid()
    ax_max_fitness.set_xlim(0, max_generations)
    
    plt.tight_layout()
    
    if save_path:
        plt.savefig(os.path.join(save_path, "max_fitness_comparison.png"), 
                   dpi=300, bbox_inches='tight')
        print("Saved max fitness comparison plot")
    
    # plt.show()


def generate_summary_statistics(experiment_data: Dict[str, pd.DataFrame]) -> pd.DataFrame:
    """Generate summary statistics for all experiments."""
    
    summary_data = []
    
    for exp_name, df in experiment_data.items():
        # Get final generation data
        final_gen = df['generation'].max()
        final_data = df[df['generation'] == final_gen]
        
        # Calculate summary statistics
        summary = {
            'experiment': exp_name,
            'total_runs': len(df['run'].unique()),
            'total_generations': final_gen + 1,
            'final_max_fitness_mean': final_data['max_fitness'].mean(),
            'final_max_fitness_std': final_data['max_fitness'].std(),
            'final_mean_fitness_mean': final_data['mean_fitness'].mean(),
            'final_mean_fitness_std': final_data['mean_fitness'].std(),
            'final_diversity_mean': final_data['diversity'].mean(),
            'final_diversity_std': final_data['diversity'].std(),
        }
        
        summary_data.append(summary)
    
    return pd.DataFrame(summary_data)


def main():
    """Main function to load data and create plots."""
    
    # Configuration
    data_dir = "data_backup/"
    save_dir = "plots/"
    
    # Example 1: Original 1D array (backward compatibility)
    experiment_names_1d = [
        "asym_figure8",
        "asym_circle", 
        "asym_slalom",
        "asym_backnforth"
    ]
    
    # Example 2: 2D array with custom colors for each row
    experiment_names_2d = [
        ["asym_circle", "sym_circle"], 
        ["asym_figure8", "sym_figure8"],   
        ["asym_slalom", "sym_slalom"],
        ["asym_backnforth","sym_shuttlerun"],  
    ]
    
    # Custom colors for each row (optional)
    column_colors = ['blue', 'red', 'green', 'orange', 'purple']
    
    # Optional row names for better file naming
    row_names = ['circle', 'figure8', 'slalom', 'shuttlerun']
    
    # Choose which experiment configuration to use
    experiment_names = experiment_names_2d  # Change this to experiment_names_1d for 1D behavior
    use_2d_plotting = isinstance(experiment_names[0], list)
    
    # Plot customization options
    fitness_figsize = (10, 6)
    diversity_figsize = (10, 6)
    comparison_figsize = (12, 8)
    xlabel_fontsize = 30
    ylabel_fontsize = 30
    tick_fontsize = 25
    
    # Create save directory if it doesn't exist
    os.makedirs(save_dir, exist_ok=True)
    
    # Load all experiment data
    print("Loading experiment data...")
    experiment_data = load_experiment_data(data_dir, experiment_names)
    
    if not experiment_data:
        print("No experiment data loaded. Please check your data directory and file paths.")
        return
    
    # Calculate and print fitness improvements
    print("\nCalculating fitness improvements...")
    improvement_stats = calculate_fitness_improvement(experiment_data)
    print_fitness_improvement_summary(improvement_stats)
    
    # Generate and save LaTeX table
    if improvement_stats:
        print("\nGenerating LaTeX table...")
        latex_table = generate_latex_table(improvement_stats, save_dir)
        print("\nLaTeX Table Code:")
        print("="*50)
        print(latex_table)
        print("="*50)
    
    # Save improvement statistics to CSV
    if improvement_stats:
        improvement_df = pd.DataFrame(improvement_stats).T  # Transpose to have experiments as rows
        improvement_df.to_csv(os.path.join(save_dir, "fitness_improvement_stats.csv"))
        print(f"\nFitness improvement statistics saved to: {os.path.join(save_dir, 'fitness_improvement_stats.csv')}")
    
    # Generate summary statistics
    print("\nGenerating summary statistics...")
    summary_stats = generate_summary_statistics(experiment_data)
    print(summary_stats)
    
    # Save summary statistics
    summary_stats.to_csv(os.path.join(save_dir, "experiment_summary.csv"), index=False)
    
    # Create plots based on experiment configuration
    if use_2d_plotting:
        print("\nCreating grouped experiment plots (2D mode)...")
        # Plot each row of experiments together
        for row_idx, experiments_row in enumerate(experiment_names):
            row_name = row_names[row_idx] if row_idx < len(row_names) else f"row_{row_idx}"
            
            print(f"Creating plots for row {row_idx} ({row_name}): {experiments_row}")
            plot_grouped_experiments(experiment_data, experiments_row, 
                                   column_colors=column_colors,
                                   save_path=save_dir,
                                   row_name=row_name,
                                   fitness_figsize=fitness_figsize,
                                   diversity_figsize=diversity_figsize,
                                   xlabel_fontsize=xlabel_fontsize,
                                   ylabel_fontsize=ylabel_fontsize,
                                   tick_fontsize=tick_fontsize)
        
        # Also create individual plots for each experiment if desired
        print("\nCreating individual experiment plots...")
        for exp_name in experiment_data.keys():
            plot_single_experiment(experiment_data, exp_name, save_dir,
                                 fitness_figsize=fitness_figsize,
                                 diversity_figsize=diversity_figsize,
                                 xlabel_fontsize=xlabel_fontsize,
                                 ylabel_fontsize=ylabel_fontsize,
                                 tick_fontsize=tick_fontsize)
        
        # Create comparison plots across all experiments
        print("\nCreating comparison plots...")
        available_experiments = list(experiment_data.keys())
        plot_comparison(experiment_data, available_experiments, save_dir,
                       figsize=comparison_figsize,
                       xlabel_fontsize=xlabel_fontsize,
                       ylabel_fontsize=ylabel_fontsize,
                       tick_fontsize=tick_fontsize)
    
    else:
        print("\nCreating individual experiment plots (1D mode)...")
        # Original behavior for 1D array
        for exp_name in experiment_data.keys():
            plot_single_experiment(experiment_data, exp_name, save_dir,
                                 fitness_figsize=fitness_figsize,
                                 diversity_figsize=diversity_figsize,
                                 xlabel_fontsize=xlabel_fontsize,
                                 ylabel_fontsize=ylabel_fontsize,
                                 tick_fontsize=tick_fontsize)
        
        # Create comparison plots (now 3 separate figures)
        print("\nCreating comparison plots...")
        available_experiments = list(experiment_data.keys())
        plot_comparison(experiment_data, available_experiments, save_dir,
                       figsize=comparison_figsize,
                       xlabel_fontsize=xlabel_fontsize,
                       ylabel_fontsize=ylabel_fontsize,
                       tick_fontsize=tick_fontsize)
    
    print("Plotting complete!")


if __name__ == "__main__":
    main()